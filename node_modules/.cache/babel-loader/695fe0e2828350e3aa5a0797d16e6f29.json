{"ast":null,"code":"import { useRef, useState } from 'react';\nimport Supercluster from 'supercluster';\nimport { useDeepCompareEffectNoCheck } from 'use-deep-compare-effect';\nimport { dequal } from 'dequal';\n\nvar useSupercluster = function useSupercluster(_ref) {\n  var points = _ref.points,\n      bounds = _ref.bounds,\n      zoom = _ref.zoom,\n      options = _ref.options;\n  var superclusterRef = useRef();\n  var pointsRef = useRef();\n\n  var _useState = useState([]),\n      clusters = _useState[0],\n      setClusters = _useState[1];\n\n  var zoomInt = Math.round(zoom);\n  useDeepCompareEffectNoCheck(function () {\n    if (!superclusterRef.current || !dequal(pointsRef.current, points)) {\n      superclusterRef.current = new Supercluster(options);\n      superclusterRef.current.load(points);\n    }\n\n    if (bounds) {\n      setClusters(superclusterRef.current.getClusters(bounds, zoomInt));\n    }\n\n    pointsRef.current = points;\n  }, [points, bounds, zoomInt]);\n  return {\n    clusters: clusters,\n    supercluster: superclusterRef.current\n  };\n};\n\nexport default useSupercluster;","map":{"version":3,"sources":["../src/index.tsx"],"names":["useSupercluster","points","bounds","zoom","options","superclusterRef","useRef","pointsRef","clusters","setClusters","useState","zoomInt","Math","useDeepCompareEffectNoCheck","dequal","supercluster","current"],"mappings":";;;;;AAaA,IAAMA,eAAe,GAAG,SAAlBA,eAAkB,CAAA,IAAA,EAAA;MAItBC,MAAAA,GAAAA,IAAAA,CAAAA,M;MACAC,MAAAA,GAAAA,IAAAA,CAAAA,M;MACAC,IAAAA,GAAAA,IAAAA,CAAAA,I;MACAC,OAAAA,GAAAA,IAAAA,CAAAA,O;AAEA,MAAMC,eAAe,GAAGC,MAAxB,EAAA;AACA,MAAMC,SAAS,GAAGD,MAAlB,EAAA;;kBACgCI,QAAQ,CAAA,EAAA,C;MAAjCF,QAAAA,GAAAA,SAAAA,CAAAA,CAAAA,C;MAAUC,WAAAA,GAAAA,SAAAA,CAAAA,CAAAA,C;;AAGjB,MAAME,OAAO,GAAGC,IAAI,CAAJA,KAAAA,CAAhB,IAAgBA,CAAhB;AAEAC,EAAAA,2BAA2B,CAAC,YAAA;AAC1B,QAAI,CAACR,eAAe,CAAhB,OAAA,IAA4B,CAACS,MAAM,CAACP,SAAS,CAAV,OAAA,EAAvC,MAAuC,CAAvC,EAAoE;AAClEF,MAAAA,eAAe,CAAfA,OAAAA,GAA0B,IAAA,YAAA,CAA1BA,OAA0B,CAA1BA;AACAA,MAAAA,eAAe,CAAfA,OAAAA,CAAAA,IAAAA,CAAAA,MAAAA;AACD;;AAED,QAAA,MAAA,EAAY;AACVI,MAAAA,WAAW,CAACJ,eAAe,CAAfA,OAAAA,CAAAA,WAAAA,CAAAA,MAAAA,EAAZI,OAAYJ,CAAD,CAAXI;AACD;;AAEDF,IAAAA,SAAS,CAATA,OAAAA,GAAAA,MAAAA;AAVyB,GAAA,EAWxB,CAAA,MAAA,EAAA,MAAA,EAXHM,OAWG,CAXwB,CAA3BA;AAaA,SAAO;AAAEL,IAAAA,QAAQ,EAAV,QAAA;AAAYO,IAAAA,YAAY,EAAEV,eAAe,CAACW;AAA1C,GAAP;AA7BF,CAAA","sourcesContent":["import { useRef, useState } from \"react\";\nimport Supercluster from \"supercluster\";\nimport { BBox, GeoJsonProperties } from \"geojson\";\nimport { useDeepCompareEffectNoCheck } from \"use-deep-compare-effect\";\nimport { dequal } from \"dequal\";\n\nexport interface UseSuperclusterArgument<P, C> {\n  points: Array<Supercluster.PointFeature<P>>;\n  bounds?: BBox;\n  zoom: number;\n  options?: Supercluster.Options<P, C>;\n}\n\nconst useSupercluster = <\n  P extends GeoJsonProperties = Supercluster.AnyProps,\n  C extends GeoJsonProperties = Supercluster.AnyProps\n>({\n  points,\n  bounds,\n  zoom,\n  options\n}: UseSuperclusterArgument<P, C>) => {\n  const superclusterRef = useRef<Supercluster<P, C>>();\n  const pointsRef = useRef<Array<Supercluster.PointFeature<P>>>();\n  const [clusters, setClusters] = useState<\n    Array<Supercluster.ClusterFeature<C> | Supercluster.PointFeature<P>>\n  >([]);\n  const zoomInt = Math.round(zoom);\n\n  useDeepCompareEffectNoCheck(() => {\n    if (!superclusterRef.current || !dequal(pointsRef.current, points)) {\n      superclusterRef.current = new Supercluster(options);\n      superclusterRef.current.load(points);\n    }\n\n    if (bounds) {\n      setClusters(superclusterRef.current.getClusters(bounds, zoomInt));\n    }\n\n    pointsRef.current = points;\n  }, [points, bounds, zoomInt]);\n\n  return { clusters, supercluster: superclusterRef.current };\n};\n\nexport default useSupercluster;\n"]},"metadata":{},"sourceType":"module"}